<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Who knew so much could be said about a value so small? I didnâ€™t even coverÂ everything!" />

    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@tabidots" />
    <meta name="twitter:creator" content="@tabidots" />
    <meta name="twitter:title" content="From zero to â€œÎµ-roâ€: Infinitesimals, floating-point, convergence, and randomÂ error" />
    <meta name="twitter:description" content="Who knew so much could be said about a value so small? I didnâ€™t even coverÂ everything!" />
    <meta name="twitter:image:src" content="../../images/selfportrait_small.png" />
    <meta name="twitter:domain" content="judosaltgenius.com" />

    <meta property="og:title" content="From zero to â€œÎµ-roâ€: Infinitesimals, floating-point, convergence, and randomÂ error" />
    <meta property="og:type" content="article" />
    <meta property="og:description" content="Who knew so much could be said about a value so small? I didnâ€™t even coverÂ everything!" />
    <meta property="og:image" content="../../images/selfportrait_small.png" />
    <meta property="og:site_name" content="judosaltgenius.com" />
    <meta property="og:url" content="../../2019/01/from-zero-to-ero" />

        <link rel="alternate"  href="http://tabidots.github.io/feeds/all.atom.xml" type="application/atom+xml" title="Judo Salt Genius Full Atom Feed"/>

        <title>From zero to â€œÎµ-roâ€: Infinitesimals, floating-point, convergence, and randomÂ error - Judo Salt Genius</title>


    <!-- KaTeX -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-beta1/katex.min.css" integrity="sha384-VEnyslhHLHiYPca9KFkBB3CMeslnM9CzwjxsEbZTeA21JBm7tdLwKoZmCt3cZTYD" crossorigin="anonymous" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-beta1/katex.min.js" integrity="sha384-O4hpKqcplNCe+jLuBVEXC10Rn1QEqAmX98lKAIFBEDxZI0a+6Z2w2n8AEtQbR4CD" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-beta1/contrib/auto-render.min.js" integrity="sha384-IiI65aU9ZYub2MY9zhtKd1H2ps7xxf+eb2YFG9lX6uRqpXCvBTOidPRCXCrQ++Uc" crossorigin="anonymous"></script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.1.0/css/font-awesome.min.css" />
    <link rel="stylesheet" href="../../theme/css/pure.css?v=0.1.0" />
      <!-- CSS specified by the user -->


      <link href="../../assets/mystyle.css" type="text/css" rel="stylesheet" />
    <link rel="stylesheet" href="../../theme/css/pygments.css" />

    <!-- for pelican_dynamic plugin -->
    <!-- end pelican_dynamic -->

</head>

<body>
<div class="pure-g-r" id="layout">
    <div class="sidebar sidebar-article pure-u">
        <header class="header-article">
                    <a href="../../author/justin-douglas" title="See posts by Justin Douglas">
                        <img class="avatar" alt="Justin Douglas" src="https://www.gravatar.com/avatar/74f13134596b2ed04a497936e3fdfd33?s=140">
                    </a>
                <h2 class="article-info">Justin Douglas</h2>



                <p class="article-date">Sat 19 January 2019</p>

                <a class="header-article-home" href="/">&larr;Home</a>
        </header>
    </div>
    <div class="pure-u">
        <div class="content">
            <section class="post">
                <header class="post-header">
                    <h1>From zero to â€œÎµ-roâ€: Infinitesimals, floating-point, convergence, and random&nbsp;error</h1>
                </header>
            </section>

                <nav class="toc">
                <div class="toc">
<ul>
<li><a href="#all-the-small-things">All the smallÂ things</a></li>
<li><a href="#machine-epsilon">Machine epsilon</a><ul>
<li><a href="#floating-point-arithmetic">Floating-pointÂ arithmetic</a></li>
<li><a href="#rounding-errors">RoundingÂ errors</a></li>
<li><a href="#granularity">Granularity</a></li>
<li><a href="#calculating-machine-epsilon">Calculating machineÂ epsilon</a></li>
</ul>
</li>
<li><a href="#linear-regression">Linear regression</a><ul>
<li><a href="#convergence-threshold">ConvergenceÂ threshold</a></li>
<li><a href="#random-error">RandomÂ error</a></li>
</ul>
</li>
<li><a href="#references">References</a></li>
</ul>
</div>
                </nav>

            
<p>One of the questions I left open from my blogâ€™s inaugural post on linear regression was <em>How do you know when youâ€™ve reachedÂ convergence?</em></p>
<p>That led me to learning about <span class="math">\(\epsilon\)</span> (epsilon), or I suppose re-learning, if you count high school calculus, in which I think it made a single brief appearance in the formal definition ofÂ limit.</p>
<p>Iâ€™m going to take a rather circuitous route to explaining the role of <span class="math">\(\epsilon\)</span> in linear regression, as I kept discovering interesting new things along theÂ way.</p>
<p>Hopefully your attention span is larger than the value of <span class="math">\(\epsilon\)</span> (harÂ har)!</p>
<h1 id="all-the-small-things">All the smallÂ things</h1>
<p><span class="math">\(\epsilon\)</span> can be found in a variety of contexts, but it always represents an <strong>infinitesimal</strong>: a quantity that it is infinitely small and basically zero, but not zero-y <em>enough</em> to notÂ exist.</p>
<p>In high school calculus, <span class="math">\(\epsilon\)</span> is the differenceÂ between</p>
<ul>
<li>the value of a function, <span class="math">\(f(x)\)</span>, near its limit point, <span class="math">\(x \rightarrow a\)</span>,Â and</li>
<li>the hypothetical value <span class="math">\(L\)</span> that the function appears to tend toward at the actual limit point <span class="math">\(a\)</span>.</li>
</ul>
<p>As the distance between <span class="math">\(x\)</span> and <span class="math">\(a\)</span> (which is called <span class="math">\(\delta\)</span>, delta) shrinks, so does <span class="math">\(\epsilon\)</span>, so the upper bounds of the two quantities move inÂ tandem.</p>
<p>You can also use <span class="math">\(\delta\)</span> and <span class="math">\(\epsilon\)</span> to describe derivatives; i.e., if <span class="math">\(dx = \delta\)</span> and <span class="math">\(\frac{dy}{dx} = \epsilon\)</span>, you can imagine how shrinking one shrinks the other, and more importantly, that the ideal value for both of them is <em>as close as you can get to zero without vanishing</em>.</p>
<p><img alt="derivative animation" src="../../images/derivative_animation.gif" title="source: https://sites.google.com/a/student.ashcoll.school.nz/bcashcoll/13-mac/differentiation-as-3-6-91578"/></p>
<h1 id="machine-epsilon">MachineÂ epsilon</h1>
<p>There is also a quantity that computer scientists call <strong>machine epsilon</strong>, which defines the smallest number that a given computing environment canÂ represent.</p>
<p>It is the largest <span class="math">\(\epsilon\)</span> thatÂ satisfies</p>
<div class="math">$$ 1 + \epsilon = 1 $$</div>
<p>which looks like another math koan, or at least some Orwellian â€œnewmathâ€ like <span class="math">\(2 + 2 = 5\)</span>.</p>
<p>Actually, that <span class="math">\(+\)</span> should have a <span class="math">\(\bigcirc\)</span> around it: <span class="math">\(\oplus\)</span>, givingÂ us</p>
<div class="math">$$ 1 \oplus \epsilon = 1 $$</div>
<p>The <span class="math">\(\oplus\)</span> means <em>floating-point addition</em>.  </p>
<p>Now, in my programming life, I have not had a need for significant precision until now, with my new interest in fields that require numericalÂ computing.</p>
<p>I also started with Python (well, JavaScript if you go way back), so I never even really had to distinguish between <code class="highlight">float</code>s and <code class="highlight">int</code>s in my codeâ€”much less think about the consequences or even know the difference, really. I just knew that if you wanted a number with a decimal point, it had to be a <code class="highlight">float</code>.</p>
<p>Once you get into doing real math with computers, though, you canâ€™t just keep <code class="highlight">float</code>ing along like that, because the limitations of machines come intoÂ play.</p>
<h2 id="floating-point-arithmetic">Floating-pointÂ arithmetic</h2>
<p><em>Floating-point arithmetic</em> was devised because computer memory, especially in machines from the very early days of computing, can only allocate a finite amount of resources toÂ data.</p>
<p>Floating-point is basically scientific notation. Letâ€™s consider the mass of a proton in scientific notation (this post isnâ€™t about physics, but as an astoundingly small value, itâ€™s a goodÂ example):</p>
<div class="math">$$ \begin{aligned} &amp; 0.0000000000000000000000000016726 \space \textrm{kg} \\
&amp;= \underbrace{1.6726}_{\textrm{significand}} \times \underbrace{10}_{\textrm{base}}  \!\!\!\!^{\overbrace{-27}^{\textrm{exponent}}} \space \textrm{kg}
\end{aligned} $$</div>
<p>The goal of scientific notation is to translate numbers of extreme magnitude into more human-friendly terms. But computers donâ€™t operate like humans do. So how can we translate this number into <em>computer</em>-friendlyÂ terms?</p>
<p>First, computers use <em>binary</em>, not base 10 (decimal system). Of course, we know that, but what does that actually mean? I always thought binary sequences were random collections of ones and zerosâ€”as if computer programs were like canvasses assaulted by a digital Jackson Pollock armed with buckets of bits andÂ bytes.</p>
<p><img alt="binary counter" src="https://upload.wikimedia.org/wikipedia/commons/7/75/Binary_counter.gif" title="(source: Ephert [CC BY-SA 4.0] https://creativecommons.org/licenses/by-sa/4.0, from Wikimedia Commons)"/></p>
<p>I am not well-versed enough in binary to explain this in words, but you can definitely see some sort of pattern in the movement of the valuesÂ here.</p>
<p>Anyway, letâ€™s rewrite the mass of a proton in binary (scroll sideways, itâ€™s a longÂ one):</p>
<div class="highlight"><pre><span></span>0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100001001000010
</pre></div>
<p>And in binary scientific notation (sortÂ of):</p>
<div class="math">$$ 1.00001001000010_{\textrm{bin}} \times 2^{-89} $$</div>
<p>Almost there. Letâ€™s take a look at how computers actually store floating-pointÂ numbers:</p>
<p><img alt="64-bit floating point storage structure" src="https://upload.wikimedia.org/wikipedia/commons/a/a9/IEEE_754_Double_Floating_Point_Format.svg" title="source: Codekaizen - Own work, [CC BY-SA 4.0] https://commons.wikimedia.org/w/index.php?curid=3595583"/></p>
<p>Every number is allocated 64 bits of memory (this can vary, but letâ€™s stick with 64). There are 52 bits for the <em>mantissa</em> (computer science term for significand), 11 for the exponent, and 1 for the sign (positve or negative). Each bit can be 1 or 0, which is the whole reason for using binary in the firstÂ place.</p>
<p>Storing the mantissa, then, is just a matter of finding a way to fit the relevant sequence of ones and zeros into the 52 slots allocated for it. If there are too many digits, chop them off; if there are too few (as in this case), add padding. This is where floating-point differs from scientificÂ notation.</p>
<div class="math">$$ 00000000 \space 00000000 \space 00000000 \space 00000000 \space
00000\textcolor{teal}{100 \space 00100100 \space 0010} \times 2^{-51} $$</div>
<p>Looks like a lot of zeros. Incidentally, the method to obtain a base-10 number from this can be expressed mathematically in a coolÂ way:</p>
<div class="math">$$ \begin{aligned}
&amp; \Bigg(\sum_{n=0}^{p-1} \textrm{bit}_n \times 2^{-n} \Bigg) \times 2^e \\
&amp;= (0 \times 2^{-0} + 0 \times 2^{-1} + 0 \times 2^{-2} + \cdots + 1 \times 2^{-50} + 0 \times 2^{-51}) \times 2^{-51} \\
&amp;= (1 \times 2^{-37} + 1 \times 2^{-42} + 1 \times 2^{-45} + 1 \times 2^{-50}) \times 2^{-51}
\end{aligned} $$</div>
<p>where <span class="math">\(\textrm{bit}_n\)</span> is the binary value of the bit at index <span class="math">\(n\)</span> (from the left, starting at 0), <span class="math">\(p\)</span> is the precision (number of bits), and <span class="math">\(e\)</span> is the exponent (which just happens to be <span class="math">\(-51\)</span> here; it has nothing to do with the number of bits for theÂ mantissa).</p>
<p>Okay, that was fun. NowÂ what?</p>
<h2 id="rounding-errors">RoundingÂ errors</h2>
<p><img alt="xkcd comic" src="https://imgs.xkcd.com/comics/e_to_the_pi_minus_pi.png" title="XKCD #217 https://xkcd.com/217/"/></p>
<p><em>If there are too many digits, chop them off</em>. This opens up a big can of worms. Or an infinitesimal one, given the topic at hand (harÂ har).</p>
<p>In exchange for the computability (read: speed and power) and storeability of floating-point numbers, we have to accept a limit to their precision. The digits of <span class="math">\(\pi\)</span>, for example, repeat endlessly. We canâ€™t expect a computer to handle them all, or a calculator, for thatÂ matter.</p>
<p>Even totally pedestrian numbers like <span class="math">\(\frac{1}{3}\)</span> go on forever. This means that computers cannot reason about fractional quantities in the way that the human mindÂ can.</p>
<div class="math">$$ \begin{aligned}
1 + \frac{1}{3} &amp;= \frac{4}{3}_{\textrm{human}} \\[0.8em]
&amp;= 1.333\overline{3}_{\textrm{dec}} \\
&amp;= 1.1010\overline{10}_{\textrm{bin}}
\end{aligned} $$</div>
<p>That is, unless you are working in some baller language like Clojure that has <code class="highlight">Ratio</code> dataÂ types:</p>
<div class="superfences-tabs">
<input checked="checked" id="__tab_1_0" name="__tabs_1" type="radio"/>
<label for="__tab_1_0">Clojure</label>
<div class="superfences-content"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">/ </span><span class="mi">1</span> <span class="mi">3</span><span class="p">)</span>        <span class="c1">; 1/3</span>
<span class="p">(</span><span class="nf">type</span> <span class="p">(</span><span class="nb">/ </span><span class="mi">1</span> <span class="mi">3</span><span class="p">))</span> <span class="c1">; clojure.lang.Ratio</span>
<span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="p">(</span><span class="nb">/ </span><span class="mi">1</span> <span class="mi">3</span><span class="p">))</span>  <span class="c1">; 4/3</span>
</pre></div></div>
<input id="__tab_1_1" name="__tabs_1" type="radio"/>
<label for="__tab_1_1">Python</label>
<div class="superfences-content"><div class="highlight"><pre><span></span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>
<span class="c1"># 1.3333333333333333</span>
</pre></div></div>
</div>
<p>Most languages seem to have implemented some sort of corrective mechanism that works in simple cases, but notice what happens with the following expressions inÂ Python:</p>
<div class="highlight"><pre><span></span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span>
<span class="c1"># 1.0</span>
<span class="mi">7</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">7</span><span class="p">)</span>
<span class="c1"># 1.0</span>
<span class="mi">1</span><span class="o">/</span><span class="mi">7</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="mi">7</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="mi">7</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="mi">7</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="mi">7</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="mi">7</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="mi">7</span>
<span class="c1"># 0.9999999999999998</span>
<span class="mi">7</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="o">/</span><span class="mi">7</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="mi">7</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="mi">7</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="mi">7</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="mi">7</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="mi">7</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="mi">7</span>
<span class="c1"># False</span>
</pre></div>
<p>Keep in mind that weâ€™re working in binary here. Unexpectedly (if you are not proficient in binary), many â€œsimpleâ€ numbers that donâ€™t repeat in decimal do inÂ binary:</p>
<div class="math">$$ \begin{aligned}
\frac{1}{10} &amp;= 0.1_{\textrm{dec}} \\
&amp;= 0.1100\overline{1100}_{\textrm{bin}}
\end{aligned} $$</div>
<p>All of this leads to <strong>floating-point rounding errors</strong> that can quickly snowball into massively erroneous output over many iterations. Hereâ€™s the example from the <a href="https://youtu.be/8iGzBMboA0I?t=3247">Rachel Thomas lecture</a>. Start with <span class="math">\(x = \frac{1}{10}\)</span> and keep applying the function to the output youÂ get:</p>
<div class="math">$$ f(x) = \begin{cases}
2x     &amp; \textrm{if } x \leq \frac{1}{2} \\
2x - 1 &amp; \textrm{if } x &gt; \frac{1}{2}
\end{cases} $$</div>
<p>If you do this by hand youÂ get</p>
<div class="math">$$ \{\tfrac{1}{10}, \tfrac{1}{5}, \tfrac{2}{5}, \tfrac{4}{5}, \tfrac{3}{5}, \overline{\tfrac{1}{5}, \tfrac{2}{5}, \tfrac{4}{5}, \tfrac{3}{5}}, \cdots\} $$</div>
<p>but when you try to execute this on aÂ computer:</p>
<div class="superfences-tabs">
<input checked="checked" id="__tab_2_0" name="__tabs_2" type="radio"/>
<label for="__tab_2_0">Python</label>
<div class="superfences-content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>
    <span class="k">elif</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">10</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">80</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div></div>
<input id="__tab_2_1" name="__tabs_2" type="radio"/>
<label for="__tab_2_1">Clojure</label>
<div class="superfences-content"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">use</span> <span class="ss">'clojure.pprint</span><span class="p">)</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">f</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt;= </span><span class="nv">x</span> <span class="mf">0.5</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="mi">2</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">1</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">pprint</span> <span class="p">(</span><span class="nb">take </span><span class="mi">80</span> <span class="p">(</span><span class="nb">iterate </span><span class="nv">f</span> <span class="mf">0.1</span><span class="p">)))</span>
</pre></div></div>
</div>
<p>it doesnâ€™t take long before the value converges on 1, which is veryÂ bizarre.</p>
<h2 id="granularity">Granularity</h2>
<p>Limited storage space leads to limited precision. A related consequence of this is that floating-point numbers are discrete, not continuous like the number line we picture in our minds. (As a kid, I think I imagined a spectrum. Fun? Yes. Accurate? Not sure.) Computers are capable of pretty precise calculations, but not perfectlyÂ precise.</p>
<p>Think of floating-point numbers like pixels. While it is true that computer displays have become less and less â€œpixelly-lookingâ€ over the years, and text rendered on a Retina screen can almost look like a printed page, we know that such output still consists ofÂ pixels.</p>
<p>The same is true for floating-point numbers. They allow for some degree of precision, but the number line they form is more like a dotted line than a solid line. (Even stranger, the density of the line changes at different scales, but Iâ€™ll leave that one for someone else toÂ explain!)</p>
<p>Take the binary number <code class="highlight">1.0</code> (regular binary, not floating-point). This is equal to the decimal number 1 as well. If we keep moving the 1 to the right and adding zeros accordingly, the value isÂ halved:</p>
<div class="math">$$ \begin{aligned}
1.0_\textrm{bin} = 1_\textrm{dec} \\
0.1_\textrm{bin} = \tfrac{1}{2}_\textrm{dec} \\
0.01_\textrm{bin} = \tfrac{1}{4}_\textrm{dec} \\
0.001_\textrm{bin} = \tfrac{1}{8}_\textrm{dec}
\end{aligned} $$</div>
<p>It is pretty clear that with 52 slots for binary values, you are going to run out of room at some pointâ€”even with the orders-of-magnitude wiggle room that the exponentÂ provides.</p>
<p>This means that after enough iterations, a value can no longer be halved. <em>That unhalvable value</em> is the smallest difference that that computing environment can represent, and it is the distance between a given number and its closest possible neighbor on the floating-point numberÂ line.</p>
<p>You could think of that as the size of a â€number pixel.â€ The whole pixel has the value of (say) its left edge, and any quantity that falls within the space of the pixel gets rounded to the edge of that pixel or the nextÂ one.</p>
<p>Machine epsilon, then, is the <em>largest quantity</em> that is less than the width of a number pixel. So it makes sense, then, that <span class="math">\(1 \oplus \epsilon = 1\)</span>.</p>
<p>This means that machine epsilon is the <em>largest possible rounding error</em> of a floating-pointÂ system.</p>
<p>It also means that on our continuous human number line, as soon as you move <em>rightward</em> of machine epsilon, you have entered the territory of the next machine-perceptible number. That is how machine epsilon defines the smallest possible difference that the system canÂ represent.</p>
<h2 id="calculating-machine-epsilon">Calculating machineÂ epsilon</h2>
<p>Before I started writing this post, I just wanted to see the code to calculate machine epsilon. But I didnâ€™t fully understand what was going on, and my dissatisfaction with that led me to go back through all the stuff I just explained. (Of course, it didnâ€™t help that I wasnâ€™t sure about the syntax of <code class="highlight">loop</code> in ClojureÂ ğŸ™ˆ)</p>
<div class="highlight"><pre><span></span><span class="c1">; Source: https://github.com/log0ymxm/gorilla-worksheets/blob/master/src/machine-epsilon.clj</span>

<span class="p">(</span><span class="k">loop </span><span class="p">[</span><span class="nv">k</span> <span class="mi">1</span> <span class="nv">s</span> <span class="mf">1.0</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nb">&lt;= </span><span class="p">(</span><span class="nb">+ </span><span class="nv">s</span> <span class="mf">1.0</span><span class="p">)</span> <span class="mf">1.0</span><span class="p">)</span>
          <span class="p">(</span><span class="nb">&gt; </span><span class="nv">k</span> <span class="mi">100</span><span class="p">))</span>
    <span class="p">[(</span><span class="nb">dec </span><span class="nv">k</span><span class="p">)</span>, <span class="p">(</span><span class="nb">* </span><span class="mf">2.0</span> <span class="nv">s</span><span class="p">)]</span>
    <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">k</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="mf">0.5</span> <span class="nv">s</span><span class="p">))))</span>
<span class="c1">; [53 2.220446049250313E-16]</span>
</pre></div>
<p>This loop is trying to find the unhalvable value I wrote about earlier. Start with <code class="highlight">s = 1.0</code> and keep halving that (moving the binary 1 rightward) until <code class="highlight"><span class="p">(</span><span class="nb">&lt;= </span><span class="p">(</span><span class="nb">+ </span><span class="nv">s</span> <span class="mf">1.0</span><span class="p">)</span> <span class="mf">1.0</span><span class="p">)</span></code> or <span class="math">\(1 + s \leq 1\)</span>. That is, until the computer no longer recognizes <code class="highlight">s</code> as havingÂ value.</p>
<p>Once that happens, youâ€™ve gone too far and fallen within the bounds of a number pixel. To find the edge of the next pixelâ€”that is, the next adjacent perceptibly different numberâ€”move the binary 1 left by one place (in decimal, thatâ€™s multiplying byÂ 2).</p>
<p>Thatâ€™s the reason for the final <code class="highlight"><span class="p">(</span><span class="nb">* </span><span class="mf">2.0</span> <span class="nv">s</span><span class="p">)</span></code> once the terminating condition isÂ met.</p>
<p><code class="highlight">k</code> tells us that the 1 is in the <span class="math">\(k\)</span>th place after the decimal point. Here, thatâ€™s the 53rd place. Thatâ€™s no surprise; we know itâ€™s a 64-bit number. But <code class="highlight">k</code> could be larger or smaller depending on the precision of the floating-point system, with higher values meaning more available places and thus higherÂ precision.</p>
<p>Julia, NumPy, and R have built-in ways to find machine epsilon (or rather, the value just a hair larger than machine epsilon). Of the three, Juliaâ€™s value is the most precise (to the same level of precision as ClojureÂ above).</p>
<div class="superfences-tabs">
<input checked="checked" id="__tab_3_0" name="__tabs_3" type="radio"/>
<label for="__tab_3_0">Julia</label>
<div class="superfences-content"><div class="highlight"><pre><span></span><span class="c"># source: https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/index.html</span>
<span class="n">julia</span><span class="o">&gt;</span> <span class="n">eps</span><span class="p">()</span>         
<span class="mf">2.220446049250313e-16</span>
<span class="n">julia</span><span class="o">&gt;</span> <span class="n">eps</span><span class="p">(</span><span class="kt">Float32</span><span class="p">)</span>  <span class="c"># 32-bit (single-precision) number</span>
<span class="mf">1.1920929f-7</span>
<span class="n">julia</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">eps</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span>
<span class="mf">1.0</span>
</pre></div></div>
<input id="__tab_3_1" name="__tabs_3" type="radio"/>
<label for="__tab_3_1">Python</label>
<div class="superfences-content"><div class="highlight"><pre><span></span><span class="c1"># source: https://stackoverflow.com/questions/19141432/python-numpy-machine-epsilon</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>        
<span class="mf">2.22044604925e-16</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> <span class="c1"># 32-bit (single-precision) number</span>
<span class="mf">1.19209e-07</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> <span class="o">/</span> <span class="mi">2</span>
<span class="mf">1.0</span>
 <span class="sb">``</span><span class="err">`</span>

<span class="sb">``</span><span class="err">`</span><span class="n">R</span> <span class="n">tab</span><span class="o">=</span>
<span class="c1"># source: https://stackoverflow.com/questions/2619543/how-do-i-obtain-the-machine-epsilon-in-r</span>
<span class="o">&gt;</span> <span class="o">.</span><span class="n">Machine</span><span class="err">$</span><span class="n">double</span><span class="o">.</span><span class="n">eps</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="mf">2.220446e-16</span>
<span class="o">&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="o">.</span><span class="n">Machine</span><span class="err">$</span><span class="n">double</span><span class="o">.</span><span class="n">eps</span> <span class="o">/</span> <span class="mi">2</span>
<span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="mi">1</span>
</pre></div></div>
</div>
<p>Just for completeness, this is that value in mathÂ notation:</p>
<div class="math">$$ \begin{aligned}
\epsilon_{\textrm{mach}} &amp;= 2.220446049250313 \times 10^{-16} \\
&amp;= 0.000 \space 000 \space 000 \space 000 \space 000 \space 000 \space 000 \space
222 \space 044 \space 604 \space 9250
\end{aligned} $$</div>
<p>So, even though I donâ€™t immediately see myself caring about the specific <em>value</em> of machine epsilon (as opposed to its <em>implications</em>), thatâ€™s prettyÂ neat.</p>
<p>Speaking of the implications of <span class="math">\(\epsilon\)</span>â€”of the machine and non-machine varietyâ€”I have to bring the discussion back to what brought me to <span class="math">\(\epsilon\)</span> in the first place: convergence in linearÂ regression.</p>
<h1 id="linear-regression">LinearÂ regression</h1>
<p><span class="math">\(\epsilon\)</span> has <em>two</em> meanings in linear regression depending on whether you are creating the model or using theÂ model.</p>
<h2 id="convergence-threshold">ConvergenceÂ threshold</h2>
<p><a href="/2019/01/loopless-loop">Previously</a>, we performed stochastic gradient descent in a way that we could see the cost decreasing with every iteration, but we still had to adjust the number of iterations manually and judge convergence by looking through the output to find the point where the next iteration wasnâ€™t really worthÂ it.</p>
<p>Itâ€™s conceptually very simple to have the computer do this for you. On each iteration, just keep track of the cost obtained after the previous iteration and compare it to the current cost. If the difference is below a certain threshold value, stopÂ iterating.</p>
<div class="math">$$ | J(\theta_{\textrm{current}}) - J(\theta_{\textrm{previous}}) | &lt; \epsilon $$</div>
<p>In this context, the threshold value is called <span class="math">\(\epsilon\)</span>. Something like <span class="math">\(0.0001\)</span> might beÂ adequate.</p>
<p>Letâ€™s take first part of the code from the lastÂ post:</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">sklearn.datasets</span>

<span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">sklearn</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">make_regression</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">n_features</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">X</span><span class="p">))</span> <span class="c1"># padding for bias column</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="c1"># this just fixes a quirk of sklearn's output</span>

<span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">cost</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
    <span class="n">num_samples</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">o</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">num_samples</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">errors</span> <span class="o">=</span> <span class="n">X</span> <span class="err">@</span> <span class="n">weights</span> <span class="o">-</span> <span class="n">y</span>
    <span class="n">cost_array</span> <span class="o">=</span> <span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">T</span> <span class="err">@</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">errors</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">num_samples</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cost_array</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
<p>and modify our <code class="highlight">train_model</code> function to show us the difference between the current and the last cost on every 50th iteration, and train for 1500Â epochs.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">train_model</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">epochs</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">num_samples</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="hll">    <span class="n">last_cost</span> <span class="o">=</span> <span class="mi">0</span>
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">epochs</span><span class="p">):</span>
        <span class="n">errors</span> <span class="o">=</span> <span class="n">X</span> <span class="err">@</span> <span class="n">weights</span> <span class="o">-</span> <span class="n">y</span>
        <span class="n">step_distance</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span> <span class="err">@</span> <span class="n">errors</span><span class="p">)</span> <span class="o">/</span> <span class="n">num_samples</span>
        <span class="n">weights</span> <span class="o">-=</span> <span class="n">learning_rate</span> <span class="o">*</span> <span class="n">step_distance</span>
<span class="hll">        <span class="n">this_cost</span> <span class="o">=</span> <span class="n">cost</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
</span><span class="hll">        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">50</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
</span><span class="hll">            <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">this_cost</span> <span class="o">-</span> <span class="n">last_cost</span><span class="p">))</span>
</span><span class="hll">        <span class="n">last_cost</span> <span class="o">=</span> <span class="n">this_cost</span>
</span>    <span class="k">return</span> <span class="n">weights</span>

<span class="n">train_model</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">1500</span><span class="p">)</span>
</pre></div>
<p>At 600 epochs, the difference falls to about <code class="highlight">0.001</code> and at 700 epochs, it falls to about <code class="highlight">0.0001</code>. Considering the difference between the initial 20 iterations was in the hundreds, I think <code class="highlight">0.001</code> is a sufficiently good <span class="math">\(\epsilon\)</span>.</p>
<p>Letâ€™s rewrite the function to stop training based on a value of <code class="highlight">epsilon</code> rather than a number <code class="highlight">epochs</code>:</p>
<div class="highlight"><pre><span></span><span class="hll"><span class="k">def</span> <span class="nf">train_model</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
</span>    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">num_samples</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">last_cost</span> <span class="o">=</span> <span class="mi">0</span>
<span class="hll">    <span class="n">epochs</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># just to know the value; not critical for training</span>
</span><span class="hll">    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
</span><span class="hll">        <span class="n">epochs</span> <span class="o">+=</span> <span class="mi">1</span>
</span>        <span class="n">errors</span> <span class="o">=</span> <span class="n">X</span> <span class="err">@</span> <span class="n">weights</span> <span class="o">-</span> <span class="n">y</span>
        <span class="n">step_distance</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span> <span class="err">@</span> <span class="n">errors</span><span class="p">)</span> <span class="o">/</span> <span class="n">num_samples</span>
        <span class="n">weights</span> <span class="o">-=</span> <span class="n">learning_rate</span> <span class="o">*</span> <span class="n">step_distance</span>
        <span class="n">this_cost</span> <span class="o">=</span> <span class="n">cost</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
<span class="hll">        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">this_cost</span> <span class="o">-</span> <span class="n">last_cost</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">epsilon</span><span class="p">:</span>
</span><span class="hll">            <span class="k">break</span>
</span>        <span class="n">last_cost</span> <span class="o">=</span> <span class="n">this_cost</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">"Completed {epochs} epochs of training."</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">"Final cost: {cost(X, y, weights)}"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">weights</span>

<span class="n">train_model</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># Completed 612 epochs of training.</span>
<span class="c1"># Final cost: 0.05001815274191081</span>
</pre></div>
<p>Nice!</p>
<h2 id="random-error">RandomÂ error</h2>
<p>I sort of lied when I said linear regressionÂ is</p>
<div class="math">$$ h_{\theta}(x) = \theta_0x_0 + \theta_1x_1 + \cdots + \theta_nx_n $$</div>
<p>I mean, it is. But that function gives the idealized, <em>predicted</em> value, the <span class="math">\(\hat y\)</span>. The <em>real</em> valueÂ is</p>
<div class="math">$$ y = \theta_0x_0 + \theta_1x_1 + \cdots + \theta_nx_n + \textcolor{magenta}{\epsilon} $$</div>
<p>(And in statistics they use <span class="math">\(\beta\)</span> rather than <span class="math">\(\theta\)</span>, just to keep you on yourÂ toes.)</p>
<p>This <span class="math">\(\epsilon\)</span> is called the <strong>random error</strong>, which sounds like the consequence of a really sloppy programmer, but is simply a way of dealing with the unavoidable fact that no model can beÂ perfect.</p>
<p>Remember how we used the <em>actual</em> error (<span class="math">\(\hatY - Y\)</span>) to compute the distance between our hypothetical line of best fit and each data point? The random error is basically sayingÂ that</p>
<ul>
<li>The regression line is the line that best fitsâ€”not <em>perfectly</em> fitsâ€”the data used to create it,Â and</li>
<li>Because of that, predictions made with the model are not likely to fall directly <em>on</em> theÂ line.</li>
</ul>
<p>That doesnâ€™t mean they <em>wonâ€™t</em>, but we canâ€™t know for sure, and itâ€™s not likely. This uncertainty is captured by <span class="math">\(\epsilon\)</span> (which we should hope is a small value, if not infinitesimal ğŸ˜…). <span class="math">\(\epsilon\)</span> is considered to be takenÂ from</p>
<ol>
<li>a normally distributed (bell curve) set ofÂ values</li>
<li>with a mean ofÂ 0</li>
</ol>
<p>The second property makes sense; our line is the best-fitting line, so its underestimates should equal its overestimates). The first property is arbitraryâ€”you could choose any kind of probability distribution, but a bell curve is apparently the simplest one that is correct enough frequentlyÂ enough.</p>
<p>This is more of a theoretical shim than anything that concerns atually coding a model, but itâ€™s still an importantÂ variable.</p>
<p>In a future post, I will talk about a topic that takes <span class="math">\(\epsilon\)</span> to the next level. StayÂ tuned!</p>
<h1 id="references">References</h1>
<ul>
<li><a href="https://en.wikibooks.org/wiki/Floating_Point/Epsilon">Floating Point/Epsilon</a>,Â Wikibooks</li>
<li><a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic">Floating-point arithmetic</a>,Â Wikipedia</li>
<li><a href="https://www0.gsb.columbia.edu/faculty/pglasserman/B6014/Regression.pdf">B6014 Managerial Statistics: Linear Regression</a>, Columbia BusinessÂ School</li>
<li><a href="https://math.stackexchange.com/questions/1051863/assumption-of-a-random-error-term-in-a-regression">Assumption of a Random error term in a regression</a>, StackExchangeÂ Mathematics</li>
</ul>

            <p class="post-footer">
                // filed
under                    <a class="post-category" href="../../tag/convergence">convergence</a>
                    <a class="post-category" href="../../tag/floating-point">floating-point</a>
                    <a class="post-category" href="../../tag/error">error</a>
                    <a class="post-category" href="../../tag/epsilon">epsilon</a>
                in <a class="post-category" href="../../category/statistics-programming">Statistics, Programming</a>&nbsp;&nbsp;&nbsp;

                <span style="display:inline-block;">
                // share on <a href="https://twitter.com/share?text=%22From%20zero%20to%20%E2%80%9C%CE%B5-ro%E2%80%9D%3A%20Infinitesimals%2C%20floating-point%2C%20convergence%2C%20and%20random%C2%A0error%3A%20Who%20knew%20so%20much%20could%20be%20said%20about%20a%20value%20so%20small%3F%20I%20didn%E2%80%99t%20even%20cover%C2%A0everything%21%22&amp;hashtags=convergence%2Cfloating-point%2Cerror%2Cepsilon" target="_blank">
                    <i class="fa fa-twitter fa-lg"></i> Twitter
                </a>
                </span>
            </p>
            <div class="hr"></div>


            <a href="#" class="go-top">Go Top</a>
<footer class="footer">
    <p>&copy; Justin Douglas  2019. Published with <a href="https://github.com/getpelican/pelican">Pelican</a>.<br />This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</p>
</footer>        </div>
    </div>
</div>
    <script>
        renderMathInElement(document.body);
    </script>

			<!-- Script specified by the user -->
			<script type="text/javascript"  src="../../assets/tweaks.js"></script>

    <!-- for pelican_dynamic plugin -->



</body>
</html>